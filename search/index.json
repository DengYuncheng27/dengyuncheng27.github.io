[{"content":"test ","date":"2023-01-16T00:00:00Z","image":"https://dengyuncheng27.github.io/p/hugo-testdocs/screen-image-city-209a8285_hu5896932946089489673.jpg","permalink":"https://dengyuncheng27.github.io/p/hugo-testdocs/","title":"【Hugo】 TestDocs"},{"content":"问题描述 clash开着系统代理的情况下，微软自带的应用基本都无法联网，比如下方的TODO应用。\n但是关闭系统代理后，它联网同步是没有问题的。\n一方面，我的代理我习惯性的一直开着， 如果为了同步一下应用数据，开一下关一下会让我感觉很麻烦。 因此这个需求其实挺硬性的。\n问题原因 原因搜了一下，不是做android开发的，不太理解。\nWin10 所有 UWP 应用均运行在被称为 App Container 的虚拟沙箱环境中，App Container 可以保证应用安全性，但同时也阻止了网络流量发送到本机（即 loopback）， 使大部分网络抓包调试工具无法对 UWP 应用进行流量分析。同样的，该机制也阻止了 UWP 应用访问 localhost，即使你在系统设置中启用了代理，也无法令 UWP 应用访问本地代理服务器。\n问题解决 Fiddler 一个抓包工具。\n进入到官网之后，点击try for free 然后随便填写邮箱，下载启动。\n进入到应用后，点击winConfig，然后弹出的窗口，把所有的全勾选上，即可。\n","date":"2022-04-24T00:00:00Z","image":"https://dengyuncheng27.github.io/p/uwp%E5%BA%94%E7%94%A8%E6%97%A0%E6%B3%95%E8%81%94%E7%BD%91/1_hu16806944223544698772.jpg","permalink":"https://dengyuncheng27.github.io/p/uwp%E5%BA%94%E7%94%A8%E6%97%A0%E6%B3%95%E8%81%94%E7%BD%91/","title":"uwp应用无法联网"},{"content":"一、跳表的基本概念 转载于 https://blog.csdn.net/xp178171640/article/details/102977210\n1、跳表的定义 跳表(SkipList)：增加了向前指针的链表叫做指针。跳表全称叫做跳跃表，简称跳表。跳表是一个随机化的数据结构，实质是一种可以进行二分查找的有序链表。跳表在原有的有序链表上增加了多级索引，通过索引来实现快速查询。跳表不仅能提高搜索性能，同时也可以提高插入和删除操作的性能。\n跳表是一个随机化的数据结构，可以被看做二叉树的一个变种，它在性能上和红黑树、AVL树不相上下，但是跳表的原理非常简单，目前在Redis和LevelDB中都有用到。\n2、跳表的详解 说明：本文中的图片均来自极客时间《数据结构与算法之美专栏》\n对于一个单链表来说，即使链表中的数据是有序的，如果我们想要查找某个数据，也必须从头到尾的遍历链表，很显然这种查找效率是十分低效的，时间复杂度为O(n)。\n那么我们如何提高查找效率呢？我们可以对链表建立一级“索引”，每两个结点提取一个结点到上一级，我们把抽取出来的那一级叫做索引或者索引层，如下图所示，down表示down指针。\n假设我们现在要查找值为16的这个结点。我们可以先在索引层遍历，当遍历索引层中值为13的时候，通过值为13的结点的指针域发现下一个结点值为17，因为链表本身有序，所以值为16的结点肯定在13和17这两个结点之间。然后我们通过索引层结点的down指针，下降到原始链表这一层，继续往后遍历查找。这个时候我们只需要遍历2个结点（值为13和16的结点），就可以找到值等于16的这个结点了。如果使用原来的链表方式进行查找值为16的结点，则需要遍历10个结点才能找到，而现在只需要遍历7个结点即可，从而提高了查找效率。\n那么我们可以由此得到启发，和上面建立第一级索引的方式相似，在第一级索引的基础上，每两个一级索引结点就抽到一个结点到第二级索引中。再来查找值为16的结点，只需要遍历6个结点即可，从而进一步提高了查找效率。\n上面举得例子中的数据量不大，所以即便加了两级索引，查找的效率提升的也不是很明显，下面通过一个64结点的链表来更加直观的感受下索引提升查找效率，如图所示，建立了五级索引。\n从图中我们可以看出来，原来没有索引的时候，查找62需要遍历62个结点，现在只需要遍历11个结点即可，速度提高了很多。那么，如果当链表的长度为10000、10000000时，通过构件索引之后，查找的效率就会提升的非常明显。\n3、跳表的时间复杂度 单链表的查找时间复杂度为：O(n)，下面分析下跳表这种数据结构的查找时间复杂度：\n我们首先考虑这样一个问题，如果链表里有n个结点，那么会有多少级索引呢？按照上面讲的，每两个结点都会抽出一个结点作为上一级索引的结点。那么第一级索引的个数大约就是n/2，第二级的索引大约就是n/4，第三级的索引就是n/8，依次类推，也就是说，第k级索引的结点个数是第k-1级索引的结点个数的1/2，那么第k级的索引结点个数为：。\n假设索引有h级，最高级的索引有2个结点，通过上面的公式，我们可以得到，从而可得：h = 。如果包含原始链表这一层，整个跳表的高度就是。我们在跳表中查找某个数据的时候，如果每一层都要遍历m个结点，那么在跳表中查询一个数据的时间复杂度就为：O(m*logn)。\n其实根据前面的分析，我们不难得出m=3，即每一级索引都最多只需要遍历3个结点，分析如下：\n如上图所示，假如我们要查找的数据是x，在第k级索引中，我们遍历到y结点之后，发现x大于y，小于y后面的结点z。所以我们通过y的down指针，从第k级索引下降到第k-1级索引。在第k-1级索引中，y和z之间只有3个结点(包含y和z)。所以，我们在k-1级索引中最多需要遍历3个结点，以此类推，每一级索引都最多只需要遍历3个结点。\n因此，m=3，所以跳表查找任意数据的时间复杂度为O(logn)，这个查找的时间复杂度和二分查找是一样的，但是我们却是基于单链表这种数据结构实现的。不过，天下没有免费的午餐，这种查找效率的提升是建立在很多级索引之上的，即空间换时间的思想。其具体空间复杂度见下文详解。\n4、跳表的空间复杂度 比起单纯的单链表，跳表就需要额外的存储空间去存储多级索引。假设原始链表的大小为n，那么第一级索引大约有n/2个结点，第二级索引大约有4/n个结点，依次类推，每上升一级索引结点的个数就减少一半，直到剩下最后2个结点，如下图所示，其实就是一个等比数列。\n这几级索引结点总和为：n/2 + n/4 + n/8 + \u0026hellip; + 8 + 4 + 2 = n - 2。所以跳表的空间复杂度为O(n)。也就是说如果将包含n个结点的单链表构造成跳表，我们需要额外再用接近n个结点的存储空间。\n其实从上面的分析，我们利用空间换时间的思想，已经把时间压缩到了极致，因为每一级每两个索引结点就有一个会被抽到上一级的索引结点中，所以此时跳表所需要的额外内存空间最多，即空间复杂度最高。其实我们可以通过改变抽取结点的间距来降低跳表的空间复杂度，在其时间复杂度和空间复杂度方面取一个综合性能，当然也要看具体情况，如果内存空间足够，那就可以选择最小的结点间距，即每两个索引结点抽取一个结点到上一级索引中。如果想降低跳表的空间复杂度，则可以选择每三个或者每五个结点，抽取一个结点到上级索引中。\n如上图所示，每三个结点抽取一个结点到上一级索引中，则第一级需要大约n/3个结点，第二级索引大约需要n/9个结点。每往上一级，索引的结点个数就除以3，为了方便计算，我们假设最高一级的索引结点个数为1，则可以得到一个等比数列，去下图所示：\n通过等比数列的求和公式，总的索引结点大约是：n/3 + n /9 + n/27 + \u0026hellip; + 9 + 3 + 1 = n/2。尽管空间复杂度还是O(n)，但是比之前的每两个结点抽一个结点的索引构建方法，可以减少了一半的索引结点存储空间。\n实际上，在软件开发中，我们不必太在意索引占用的额外空间。在讲数据结构的时候，我们习惯性地把要处理的数据看成整数，但是在实际的软件开发中，原始链表中存储的有可能是很大的对象，而索引结点只需要存储关键值和几个指针，并不需要存储对象，所以当对象比索引结点大很多时，那索引占用的额外空间就可以忽略了。\n5、跳表的插入 跳表插入的时间复杂度为：O(logn)，支持高效的动态插入。\n在单链表中，一旦定位好要插入的位置，插入结点的时间复杂度是很低的，就是O(1)。但是为了保证原始链表中数据的有序性，我们需要先找到要插入的位置，这个查找的操作就会比较耗时。\n对于纯粹的单链表，需要遍历每个结点，来找到插入的位置。但是对于跳表来说，查找的时间复杂度为O(logn)，所以这里查找某个数据应该插入的位置的时间复杂度也是O(logn)，如下图所示：\n6、跳表的删除 跳表的删除操作时间复杂度为：O(logn)，支持动态的删除。\n在跳表中删除某个结点时，如果这个结点在索引中也出现了，我们除了要删除原始链表中的结点，还要删除索引中的。因为单链表中的删除操作需要拿到删除结点的前驱结点，然后再通过指针操作完成删除。所以在查找要删除的结点的时候，一定要获取前驱结点（双向链表除外）。因此跳表的删除操作时间复杂度即为O(logn)。\n7、跳表索引动态更新 当我们不断地往跳表中插入数据时，我们如果不更新索引，就有可能出现某2个索引节点之间的数据非常多的情况，在极端情况下，跳表还会退化成单链表，如下图所示：\n作为一种动态数据结构，我们需要某种手段来维护索引与原始链表大小之间的平衡，也就是说，如果链表中的结点多了，索引结点就相应地增加一些，避免复杂度退化，以及查找、插入和删除操作性能的下降。\n如果你了解红黑树、AVL树这样的平衡二叉树，你就会知道它们是通过左右旋的方式保持左右子树的大小平衡，而跳表是通过随机函数来维护“平衡性”。\n当我们往跳表中插入数据的时候，我们可以通过一个随机函数，来决定这个结点插入到哪几级索引层中，比如随机函数生成了值K，那我们就将这个结点添加到第一级到第K级这个K级索引中。如下图中要插入数据为6，K=2的例子：\n随机函数的选择是非常有讲究的，从概率上讲，能够保证跳表的索引大小和数据大小平衡性，不至于性能的过度退化。至于随机函数的选择，见下面的代码实现过程，而且实现过程并不是重点，掌握思想即可。\n8、跳表的性质 (1) 由很多层结构组成，level是通过一定的概率随机产生的； (2) 每一层都是一个有序的链表，默认是升序 ； (3) 最底层(Level 1)的链表包含所有元素； (4) 如果一个元素出现在Level i 的链表中，则它在Level i 之下的链表也都会出现； (5) 每个节点包含两个指针，一个指向同一链表中的下一个元素，一个指向下面一层的元素。\n","date":"2022-03-14T00:00:00Z","image":"https://dengyuncheng27.github.io/p/%E8%B7%B3%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/1_hu5896932946089489673.jpg","permalink":"https://dengyuncheng27.github.io/p/%E8%B7%B3%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/","title":"跳表的基本原理"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\nCreate a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so: 1 2 3 {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} To enable KaTex globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTex on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions\nExamples Block math: $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$\n","date":"2019-03-08T00:00:00Z","permalink":"https://dengyuncheng27.github.io/p/math-typesetting/","title":"Math Typesetting"},{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site\u0026rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n1 2 3 .emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; } ","date":"2019-03-05T00:00:00Z","image":"https://dengyuncheng27.github.io/p/emoji-support/the-creative-exchange-d2zvqp3fpro-unsplash_hu5876398126655421130.jpg","permalink":"https://dengyuncheng27.github.io/p/emoji-support/","title":"Emoji Support"},{"content":"测试 如果你想在这个主题下协作的话，你就得建立如下结构，文件夹名是你的文章名，md文档的名字必须是index开头。\n此外，图片的话放在同级目录下。\n不知道为什么，这个文件索引不到。 很奇怪，工作流总是执行的不如预期。\n","date":"0001-01-01T00:00:00Z","image":"https://dengyuncheng27.github.io/p/writing/screen-image-city-209a8285_hu5896932946089489673.jpg","permalink":"https://dengyuncheng27.github.io/p/writing/","title":"【Hugo】 Writing"}]